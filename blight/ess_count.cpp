#include "blight.h"
using namespace std;


string reverseComplement(string base) {
    size_t len = base.length();
    char* out = new char[len + 1];
    out[len] = '\0';
    for (int i = 0; i < len; i++) {
        if (base[i] == 'A') out[len - i - 1] = 'T';
        else if (base[i] == 'C') out[len - i - 1] = 'G';
        else if (base[i] == 'G') out[len - i - 1] = 'C';
        else if (base[i] == 'T') out[len - i - 1] = 'A';
    }
    string outString(out);
    free(out);
    return outString;
}


vector<string> string_split (const string &s, char delim) {
    vector<string> result;
    stringstream ss (s);
    string item;
    while (getline (ss, item, delim)) {
        result.push_back (item);
    }
    return result;
}

string getFileName(const string& s) {
   char sep = '/';
   size_t i = s.rfind(sep, s.length());
   if (i != string::npos) {
      return(s.substr(i+1, s.length() - i));
   }
   return s;
}

string getBaseName(string filename){
  std::size_t found = filename.find(".fa.essd");
  if (found!=std::string::npos){
    return filename.substr(0, filename.length()-8);
  }else{
    return filename;
  }
}

int main(int argc, char** argv) {

    //int kmer_size = (int) strtol(argv[1], NULL, 10);
    //string basename = string(argv[2]);

    // string input_kff_outstr_with_count=basename+".outstr";
    // string input_spss_fasta_without_count=basename+".fa.essd";
    // string output_spss_fasta_with_count=basename+".instr";

    int kmer_size=0;
    string input_kff_outstr_with_count="";
    string input_spss_fasta_without_count="";
    //string output_spss_fasta_with_count="ess_with_data.instr";
    string output_spss_fasta_with_count="";

    int core_number(0);
    int file_number_exponent(4);
    int subsampling_bits(0);

    // help:
    // -k <kmer size> -i <file generated by UST/ESS SPSS> -d <file contatining k-mer and data>
    char c;
    while( ( c = getopt (argc, argv, "i:k:d:t:") ) != -1 )
    {
        switch(c)
        {
            case 'i':
                if(optarg)
                input_spss_fasta_without_count=string(optarg);
                break;
            case 'k':
                if(optarg) {
                    kmer_size = std::atoi(optarg) ;
                    if(kmer_size<=0){
                        fprintf(stderr, "Error: Specify a positive k value.\n");
                        exit(EXIT_FAILURE);
                    }
                }else{
                    fprintf(stderr, "Usage: %s -k <kmer size> -i <file generated by UST/ESS SPSS> -d <file contatining k-mer and data>  -t <number of cores>]\n",
                            argv[0]);
                    exit(EXIT_FAILURE);
                }
                break;
            case 'd':
                if(optarg) {
                input_kff_outstr_with_count=string(optarg);
                }
                break;
            case 't':
                if(optarg) {
                    core_number = std::atoi(optarg) ;
                    if(core_number<=0){
                        fprintf(stderr, "Error: Specify a positive value.\n");
                        exit(EXIT_FAILURE);
                    }
                }else{
                    fprintf(stderr, "Usage: %s -k <kmer size> -i <file generated by UST/ESS SPSS> -d <file contatining k-mer and data> -t <number of cores>]\n",
                            argv[0]);
                    exit(EXIT_FAILURE);
                }
                break;
            default: //
                    fprintf(stderr, "Usage: %s -k <kmer size> -i <file generated by UST/ESS SPSS> -d <file contatining k-mer and data>  -t <number of cores>]\n",
                            argv[0]);
                    exit(EXIT_FAILURE);
        }
    }
    if(kmer_size==0 || core_number==0 ) { //|| input_kff_outstr_with_count=="" || input_spss_fasta_without_count=""
        fprintf(stderr, "Usage: %s -k <kmer size> -i <file generated by UST/ESS SPSS> -d <file contatining k-mer and data>  -t <number of cores>]\n",
                argv[0]);
        exit(EXIT_FAILURE);
    }
    output_spss_fasta_with_count=getBaseName(getFileName(input_spss_fasta_without_count))+".essd_instr";
    kmer_Set_Light blight_index_5(kmer_size, core_number);
    blight_index_5.construct_index(input_spss_fasta_without_count, "wdir");

    //cout<<"Debug checkpoint # 1"<<endl;

    blight_index_5.dump_disk("blight_index.gz");

    std::vector<uint64_t> abundance(blight_index_5.get_kmer_number(), 0);
    //cout<<"Debug checkpoint # 2"<<endl;

    vector<int64_t> hash_vector;
    ifstream f_sset;
    f_sset.open (input_kff_outstr_with_count);

    //cout<<"Debug checkpoint # 3"<<endl;
    string line;
    uint64_t count=0;  //change uint64_t depending on max data size

    uint64_t numkmer=blight_index_5.get_kmer_number();
    cout << "Total number of k-mers = "<<numkmer << " "<<endl;

    while ( getline (f_sset,line) )
    {
        stringstream ss(line);
        string kmer = "";
        ss >> kmer;
        hash_vector=blight_index_5.get_hashes_query(kmer);
            for(uint64_t i(0);i<hash_vector.size();++i){
                int64_t indice(hash_vector[i]);
                //If the kmer is in the index its indice will be a position in the abundance vector
                if(indice!=-1){
                    ss >> count;
                    if(indice >= numkmer){
                    cout<<"Error: bad indice "<< indice<<endl;
                    exit(EXIT_FAILURE);
                    }
                    abundance[indice]=count;
                }
            }
    }
    //cout<<"Debug checkpoint # 4"<<endl;
    f_sset.close();
    ifstream f_spss(input_spss_fasta_without_count);
    ofstream f_out(output_spss_fasta_with_count);

    bool minimizer_mode=false;

    while ( getline (f_spss,line) )
    {
        stringstream ss(line);
        string spell = "";
        ss >> spell;
        if(spell.at(0)=='>'){
            continue;
        }

        if (!minimizer_mode){
            hash_vector=blight_index_5.get_hashes_query(spell);
            f_out<<spell<<" ";
                for(uint64_t i(0);i<hash_vector.size();++i){
                    int64_t indice(hash_vector[i]);
                    if(indice!=-1){
                        if(i!=0){
                            f_out<< ",";
                        }
                        f_out<< abundance[indice];
                    }
                }
                f_out<<endl;
        }
    }
    f_out.close();
    f_sset.close();
    //cout<<"Debug checkpoint # 5"<<endl;
    cout<<"Finished! Output is in "+output_spss_fasta_with_count<<endl;

    return 0;
}
